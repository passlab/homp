\section{Program data access Graph}
In the visualization tool, the Program data access graph shows the array and computation distributions from program level. It is generated by complier analysis with support of language extensions. This can be illustrated by following program and its corresponding Program data access graph.
\begin{figure}[!t]
\centering
\includegraphics [width=2.5in] {"program 1".png}
\caption{OpenMP Parallel Program-1}
\label{fig1}
\end{figure}
In fig.1, line 1-3 deals with declaration of matrices A, B and C. Line 4, 5 does sequential initialization of matrices to zero. Line 6, 7 does BLOCK distribution of matrices A, B and C and aligns them. Thus, 6-8 initializes the outer for parallel for operation of matrix addition. Line 8.a -8.c performs parallel for operation for inner loop of matrix addition. At the program beginning, the team consists of a single thread. A ‘parallel’ construct splits the current thread into a new team of threads for the duration of the next block/statement, after which the team merges back into one. ‘For’ divides the work of the for-loop among the threads of the current team. It does not create threads, it only divides the work amongst the threads of the currently executing team. Thus, ‘parallel for’ is a shorthand for two commands at once: parallel and for. Parallel creates a new team, and for splits that team to handle different portions of the loop. Thus, the corresponding program data access graph for this OpenMP Parallel Program-1 is represented in fig. 2. In fig. 2 the first two nodes 0 and 1 represents the two threads generated by outer parallel for loop. The next two nested nodes 0 and 1 represent new two threads generated by inner parallel for loop for each thread in outer for loop. Fig. 2. only represents the array distribution for matrix A. The highlighted portion of the matrix under the nodes show the range of matrix on which the corresponding thread nodes work on. The different color schemes show the mapping of each portion of the matrix with the virtual memory. Similarly the mapping will be shown for matrix B and C. Thus this allows user to understand which thread is responsible for which part of the array or loop computation. It also allow user to understand the mapping of array in virtual region.
\begin{figure}[!t]
\centering
\includegraphics [width=2.5in] {"mem".png}
\caption{Program data access graph and data access in memory layout}
\label{fig2}
\end{figure}

\begin{figure}[!t]
\centering
\includegraphics [width=2.5in] {"program data".png}
\caption{Visualization of array and loop distribution using GraphML}
\label{fig3}
\end{figure}
Fig. 3 represents the total threads and their corresponding data on which they are operating. It also represent the distribution of array x and y and for loop on CPU/GPU/Simulator. It also shows the range of the distribution of array and for loop on each device. Thus, user get clear insight of data distribution on each thread and device.