\section{Motivation}
Systems with NUMA architecture are challenging to program efficiently. If the data accesses performed by a multithreaded program are remote, there will be bottleneck of contention for limited bandwidth between NUMA nodes. This problem can be more serious if a large data arrays are mapped to a single NUMA node and many threads compete for the limited bandwidth in and out of that node. This situation is very common than one might think in NUMA architecture. By default, current Linux systems employ a “first-touch” policy to bind pages of memory newly-allocated from the operating system to memory banks directly attached to the NUMA domain where page resides on the thread that first accesses it. Because of this, if a data array is initialized by a single thread, but multiple threads process the data later, severe contention can arise. Tailoring a program for efficient execution on systems with multiple NUMA nodes requires identifying and adjusting data and computation layouts to minimize each thread’s use of remote data and avoid contention for bandwidth between NUMA nodes. This motivated us to design a visualization tool that can provide an insight into NUMA-related performance losses that are important for guiding optimization of multithreaded programs.