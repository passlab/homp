%\newpage
\section{Introduction}

\IEEEPARstart{T}{he} behavior of parallel programs on advanced computer architectures is often extremely complex, and hardware or software performance monitoring of such programs can generate vast quantities of data. Analysis of the performance of high-performance computing (HPC) systems and applications is hence a very significant and complex task. Thus, it seems natural to use visualization techniques to gain insight into the behavior of parallel programs so that their performance can be understood and improved. The performance of most of the HPC applications is limited by the available memory bandwidth instead of the processorâ€™s floating-point performance. Modern microarchitectures integrate the memory controller directly on the processor chip, in order to increase the memory bandwidth. This give rise to a non-uniform memory access (NUMA) behavior in multi socket configurations. In NUMA architecture, as local memory accesses are faster than remote memory accesses, the memory access time depends on the memory location relative to a processor core. If shared memory parallel applications are not coded effectively and if the number of remote accesses are high than local accesses then they may exhibit poor performance on NUMA architectures. Thus, an effective performance visualization tool promises performance optimization in NUMA-aware memory allocation environment. Several performance tools are capable of analyzing the data access of shared memory parallel applications on NUMA architectures. However, most of the tools does not give the details on how data are layered-out and accessed during parallel execution. Some of the tools provide just the quantitative profiling results for memory performance such as number of cache misses, number of memory accesses and simply show the bars of collective numbers for the whole program executions. Consequently, users need to co-related performance numbers with program data access and memory behavior. Hence it needs lots of manual work and expertise on the part of user too to identify performance bottleneck and provide solutions. Most of the times, solutions are trial-and-test approach which are quite tedious. In this work, we explore a new approach for performance visualization using program data access graph and data layout/access in memory graph using GraphML.


